
#pragma kernel Trace

static const float eps = 1e-4;
static const float inf = 1e8;
static const float PI = 3.14159265;


float4 sourcePos;
float4 listenerPos;

float inputGain;
float listenerRadius, speedOfSound;
int rayCount, debugRayCount, maxBounceCount, numWalls;
uint rngStateOffset;

struct AudioMat {
    float absorption;
    float scattering; // 0=Mirror, 1=Diffuse
    float transmission; // Probability of passing through (0 to 1)
    float ior;
};

struct Wall { 
    float2 a, b, normal; 
    AudioMat mat; 
};

struct RayInfo { 
    float timeDelay; 
    float energy; 
    float2 hitPoint; 
};

StructuredBuffer<Wall> walls;
AppendStructuredBuffer<RayInfo> rayInfoBuffer;
RWStructuredBuffer<float4> debugRays;

float random(inout uint state) {
    state = state * 747796405 + 2891336453;
    uint res = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    return ((res >> 22) ^ res) / 4294967295.0;
}
float intersect(float2 o, float2 d, float2 a, float2 b) {
    float2 v1 = o - a, v2 = b - a, v3 = float2(-d.y, d.x);
    float dotP = dot(v2, v3);
    if (abs(dotP) < eps) return inf;
    float t1 = (v2.x * v1.y - v2.y * v1.x) / dotP;
    float t2 = dot(v1, v3) / dotP;
    return (t1 >= eps && t2 >= 0 && t2 <= 1) ? t1 : inf;
}
float intersectCircle(float2 rayPos, float2 rayDir, float2 center, float radius) {
    float2 L = center - rayPos;
    float tca = dot(L, rayDir);
    if (tca < 0) return inf; // Listener is behind the ray
    
    float d2 = dot(L, L) - tca * tca;
    float r2 = radius * radius;
    if (d2 > r2) return inf; // Ray misses the circle
    
    float thc = sqrt(r2 - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;
    
    if (t0 > eps) return t0;
    if (t1 > eps) return t1;
    return inf;
}

bool checkVis(float2 start, float2 end, float dist) {
    float2 dir = (end - start) / dist;
    for (int w = 0; w < numWalls; w++) {
        float d = intersect(start, dir, walls[w].a, walls[w].b);
        if (d < dist - 0.1) return false; 
    }
    return true;
}

float3 Refract(float3 i, float3 n, float eta) {
    float cosi = dot(-i, n);
    float cost2 = 1.0 - eta * eta * (1.0 - cosi*cosi);
    float3 t = eta * i + ((eta * cosi - sqrt(abs(cost2))) * n);
    return t * (float3)(cost2 > 0); // Return 0 if Total Internal Reflection occurs
}

[numthreads(64,1,1)]
void Trace (uint3 id : SV_DispatchThreadID) {
    uint rng = id.x + rngStateOffset * 719393;
    float angle = ((id.x + random(rng)) / rayCount) * 2 * PI;
    
    float2 rayDir = float2(cos(angle), sin(angle));
    float2 rayPos = sourcePos.xy;
    float curEnergy = inputGain;
    float accumTime = 0;
    float totalDist = 0;

    float currentIOR = 1.0; 
    float curSpeed = speedOfSound; 
    int wallDepth = 0;

    if (id.x < 100) 
        debugRays[id.x * (maxBounceCount + 1)] = float4(rayPos, curEnergy, 0);


    for (int i = 0; i < maxBounceCount; i++) {
        float closest = inf; int hitIdx = -1;

        // get closest wall dist and index
        for (int w = 0; w < numWalls; w++) {
            float d = intersect(rayPos, rayDir, walls[w].a, walls[w].b);
            if (d < closest) { closest = d; hitIdx = w; }
        }
        
        // check if we are intersecting listener
        if (wallDepth == 0) {
            float distToListener = intersectCircle(rayPos, rayDir, listenerPos.xy, listenerRadius);
            if (distToListener < closest && distToListener < inf) {
                RayInfo info;
                info.hitPoint = rayPos + rayDir * distToListener; 
                info.timeDelay = accumTime + (distToListener / curSpeed);
                float totalD = totalDist + distToListener;
                info.energy = curEnergy / max(1.0, totalD * totalD);
                rayInfoBuffer.Append(info);
            }
        }
        
        if (hitIdx == -1) {
            if (id.x < (uint)debugRayCount) 
                debugRays[id.x * (maxBounceCount + 1) + (i + 1)] = float4(rayPos + rayDir * 20.0, 0, 0);
            break;
        }

        // Move Ray
        rayPos += rayDir * closest;
        accumTime += closest / curSpeed;
        totalDist += closest;

        if (id.x < 100) 
            debugRays[id.x * (maxBounceCount + 1) + (i + 1)] = float4(rayPos, curEnergy, 0);
        
        Wall wall = walls[hitIdx];

        // NEE
        if (wallDepth == 0) {
            float2 toList = listenerPos.xy - rayPos;
            float distList = length(toList);

            if (checkVis(rayPos + wall.normal * eps, listenerPos.xy, distList)) {
                float2 effN = dot(rayDir, wall.normal) > 0 ? -wall.normal : wall.normal;
                float cosT = max(0, dot(effN, toList / distList));
                
                float totalD = totalDist + distList;
                float contrib = curEnergy * (1.0 - wall.mat.absorption) * (cosT * 0.5) * (1.0 / (totalD*totalD));

                if (contrib > 1e-5) {
                    RayInfo info;
                    info.hitPoint = rayPos;
                    info.timeDelay = accumTime + (distList / speedOfSound);
                    info.energy = contrib;
                    rayInfoBuffer.Append(info);
                }
            }
        }
        
        curEnergy *= (1.0 - wall.mat.absorption);
        if (curEnergy < 1e-3) break;

        // depth tracking
        bool entering = dot(rayDir, wall.normal) < 0;
        float2 n = entering ? wall.normal : -wall.normal;
        float wallSpeed = speedOfSound / wall.mat.ior; // IOR is inverse Speed Multiplier
        float nextSpeed;

        if (entering) {
            nextSpeed = wallSpeed;
        } else {
            nextSpeed = (wallDepth <= 1) ? speedOfSound : wallSpeed;
        }

        // snells law
        float eta = nextSpeed / curSpeed;
        float rngVal = random(rng);

        if (rngVal < wall.mat.transmission) {
            float3 refr = Refract(float3(rayDir, 0), float3(n, 0), eta);
            
            if (length(refr) > 0) {
                float2 nextDir = refr.xy;
                // jitter
                if (wall.mat.scattering > 0) {
                    float jitter = (random(rng) - 0.5) * 2.0 * wall.mat.scattering;
                    float s = sin(jitter), c = cos(jitter);
                    nextDir = float2(nextDir.x * c - nextDir.y * s, nextDir.x * s + nextDir.y * c);
                }

                rayDir = normalize(nextDir);
                
                curSpeed = nextSpeed;
                if (entering) wallDepth++; else wallDepth = max(0, wallDepth - 1);

                rayPos += rayDir * eps;
                continue;
            }
        }

        // reflection
        float2 specularDir = reflect(rayDir, n);
        
        float diffAng = asin(2.0 * random(rng) - 1.0);
        float s = sin(diffAng), c = cos(diffAng);
        float2 diffuseDir = float2(n.x * c - n.y * s, n.x * s + n.y * c);

        rayDir = normalize(lerp(specularDir, diffuseDir, wall.mat.scattering));
        
        rayPos += n * eps;
    }
}

#pragma kernel ProcessHits

RWStructuredBuffer<float> ImpulseResponse;
StructuredBuffer<RayInfo> RawHits;
int SampleRate;
int ImpulseLength;
int HitCount;

[numthreads(64, 1, 1)]
void ProcessHits(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)HitCount) return;

    RayInfo hit = RawHits[id.x];

    int index = (int)(hit.timeDelay * SampleRate);

    if (index < ImpulseLength && index >= 0)
    {
        ImpulseResponse[index] = ImpulseResponse[index] + hit.energy; 
    }
}

#pragma kernel ClearImpulse
[numthreads(256, 1, 1)]
void ClearImpulse(uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)ImpulseLength)
        ImpulseResponse[id.x] = 0.0;
}

#pragma kernel DrawIR

RWTexture2D<float4> DebugTexture; 
StructuredBuffer<float> ImpulseResponseSpectrogram; // Flattened 2D array [Time * BlockSize + Freq]
int accumCount;
int TexWidth, TexHeight; 
int BlockSize;
float DebugGain;

float3 TurboColormap(float t) {
    const float3 c0 = float3(0.114089010972696, 0.0828523085427725, 0.373056117872124);
    const float3 c1 = float3(0.939163989053249, 0.63582637685938, 0.252462255008546);
    const float3 c2 = float3(4.55581134044558, 5.09337581958047, 4.30604811823795);
    const float3 c3 = float3(-6.75629555431633, -7.56708781989445, -7.03926585970258);
    const float3 c4 = float3(2.57147775533134, 2.76796472099351, 2.79336118471556);
    // Simple cosine approximation for speed if exact Turbo is overkill, but let's just map Magnitude -> Color
    return lerp(float3(0,0,0), float3(1,1,1), t); // Fallback: Black to White
}

float3 HeatMap(float v) {
    float3 c = float3(1.0, 1.0, 1.0);
    if (v < 0.25) {
        c = lerp(float3(0.0, 0.0, 1.0), float3(0.0, 1.0, 1.0), v * 4.0);
    } else if (v < 0.5) {
        c = lerp(float3(0.0, 1.0, 1.0), float3(0.0, 1.0, 0.0), (v - 0.25) * 4.0);
    } else if (v < 0.75) {
        c = lerp(float3(0.0, 1.0, 0.0), float3(1.0, 1.0, 0.0), (v - 0.5) * 4.0);
    } else {
        c = lerp(float3(1.0, 1.0, 0.0), float3(1.0, 0.0, 0.0), (v - 0.75) * 4.0);
    }
    return c;
}

[numthreads(8, 8, 1)]
void DrawIR(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)TexWidth || id.y >= (uint)TexHeight) return;

    // Map Texture X -> Time (Partition Index), Texture Y -> Frequency
    int timeIdx = (int)((id.x / (float)TexWidth) * ImpulseLength);
    int freqIdx = (int)((id.y / (float)TexHeight) * BlockSize);
    
    // Safety check
    if (timeIdx >= ImpulseLength) timeIdx = ImpulseLength - 1;
    if (freqIdx >= BlockSize) freqIdx = BlockSize - 1;

    // Get the flattened index: [Time * BlockSize + Freq]
    // Assuming ImpulseResponse is now the spectrogram buffer (magnitude)
    int flatIdx = timeIdx * BlockSize + freqIdx;
    
    float magnitude = ImpulseResponseSpectrogram[flatIdx] / max(1, accumCount);
    
    // Logarithmic scaling is usually better for audio visualization
    float intensity = log(1.0 + magnitude * DebugGain); 
    intensity = saturate(intensity);

    float3 col = HeatMap(intensity);
    
    DebugTexture[id.xy] = float4(col, 1.0);
}


#pragma kernel AudioConvolve

StructuredBuffer<complex> InputFFTAudio;
RWStructuredBuffer<complex> OutputAudioSpectrogram;

const int BlockSize; // how many frequencies the fft outputs
const int IRLength;

[numthreads(256, 1, 1)]
void AudioConvolve(uint3 id : SV_DispatchThreadID)
{
    int i = id.x; 
    if (i >= BlockSize) return;

    complex val = InputFFTAudio[i];

    if (dot(val, val) > eps * eps) 
    {
        for (int n = 0; n < IRLength; n++) 
        {
            int idx = n * BlockSize + i;
            if (ImpulseResponse[idx] <= eps) continue;
            OutputAudioSpectrogram[idx] = complex_mult(val, complex(ImpulseResponse[idx], 0));
        }
    }
}


// FFT and IFFT Kernels
typedef float2 complex;

const int WINDOW_SIZE = 128;
complex complex_exp(float theta) {
    return complex(cos(theta), sin(theta));
}

complex complex_mult(complex a, complex b) {
    return complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

complex nth_root(int n, int k) {
    float angle = -2.0 * PI * k / n;
    return complex_exp(angle);
}

#pragma kernel FFT
RWStructuredBuffer<complex> Data;
[numthreads(1, 1, 1)]
void FFT(uint3 id : SV_DispatchThreadID) {
    int n = WINDOW_SIZE;
    int bits = (int)log2(n);

    // Bit-reversal permutation
    for (uint i = 0; i < (uint)n; i++) {
        uint rev = reversebits(i) >> (32 - bits);
        if (i < rev) {
            complex temp = Data[i];
            Data[i] = Data[rev];
            Data[rev] = temp;
        }
    }

    for (int s = 1; s <= bits; s++) {
        int m = 1 << s;
        int m2 = m >> 1;
        complex w_m = nth_root(m, 1);

        for (int k = 0; k < n; k += m) {
            complex w = complex(1, 0);
            for (int j = 0; j < m2; j++) {
                complex t = complex_mult(w, Data[k + j + m2]);
                complex u = Data[k + j];
                Data[k + j] = u + t;
                Data[k + j + m2] = u - t;
                w = complex_mult(w, w_m);
            }
        }
    }
}

complex nth_root_inv(int n, int k) {
    float angle = 2.0 * PI * k / n;
    return complex_exp(angle);
}

#pragma kernel IFFT
[numthreads(1, 1, 1)]
void IFFT(uint3 id : SV_DispatchThreadID) {
    int n = WINDOW_SIZE;
    int bits = (int)log2(n);

    // Bit-reversal permutation
    for (uint i = 0; i < (uint)n; i++) {
        uint rev = reversebits(i) >> (32 - bits);
        if (i < rev) {
            complex temp = Data[i];
            Data[i] = Data[rev];
            Data[rev] = temp;
        }
    }

    for (int s = 1; s <= bits; s++) {
        int m = 1 << s;
        int m2 = m >> 1;
        complex w_m = nth_root_inv(m, 1);

        for (int k = 0; k < n; k += m) {
            complex w = complex(1, 0);
            for (int j = 0; j < m2; j++) {
                complex t = complex_mult(w, Data[k + j + m2]);
                complex u = Data[k + j];
                Data[k + j] = u + t;
                Data[k + j + m2] = u - t;
                w = complex_mult(w, w_m);
            }
        }
    }

    // Normalization
    float invN = 1.0 / n;
    for (int idx = 0; idx < n; idx++) {
        Data[idx] = Data[idx] * invN;
    }
}


