#pragma kernel Trace

#include "Common.hlsl"

float4 sourcePos;
float4 listenerPos;
float inputGain;
float listenerRadius, speedOfSound;
int rayCount, debugRayCount, maxBounceCount, numWalls;
uint rngStateOffset;

struct AudioMat {
    float absorption;
    float scattering;
    float transmission;
    float ior;
};

struct Wall { 
    float2 a, b, normal; 
    AudioMat mat; 
};

struct RayInfo { 
    float timeDelay; 
    float energy; 
    float frequency;
    float2 hitPoint; 
};

StructuredBuffer<Wall> walls;
AppendStructuredBuffer<RayInfo> rayInfoBuffer;
RWStructuredBuffer<float4> debugRays;
RWStructuredBuffer<float> Spectrogram;
StructuredBuffer<RayInfo> RawHits;
StructuredBuffer<float2> FFTData;  // Complex FFT values per frequency bin

int SampleRate, ChunkSize, HitCount, accumCount;
int NumFrequencyBins, TimeSteps;
int TexWidth, TexHeight;
float DebugGain;

bool checkVis(float2 start, float2 end, float dist) {
    float2 dir = (end - start) / dist;
    for (int w = 0; w < numWalls; w++) {
        float d = intersect(start, dir, walls[w].a, walls[w].b);
        if (d < dist - 0.1) return false; 
    }
    return true;
}

[numthreads(64,1,1)]
void Trace (uint3 id : SV_DispatchThreadID) {
    uint rng = id.x + rngStateOffset * 719393;
    
    // Determine which frequency bin this ray belongs to based on FFT amplitudes
    // Each frequency gets rays proportional to its amplitude
    float totalEnergy = 0;
    float freqAmplitudes[128];  // Max 128 frequency bins (chunkSize/2)
    
    // Calculate total energy and individual amplitudes
    for (int f = 0; f < NumFrequencyBins && f < 128; f++) {
        float2 complexVal = FFTData[f];
        float magnitude = length(complexVal);
        freqAmplitudes[f] = magnitude;
        totalEnergy += magnitude;
    }
    
    // Normalize to get probability distribution
    if (totalEnergy < eps) return; // No energy, skip ray
    
    // Randomly select frequency based on energy distribution
    float randVal = random(rng) * totalEnergy;
    float cumulative = 0;
    int selectedFreq = 0;
    
    for (int f = 0; f < NumFrequencyBins && f < 128; f++) {
        cumulative += freqAmplitudes[f];
        if (randVal <= cumulative) {
            selectedFreq = f;
            break;
        }
    }
    
    // Calculate actual frequency in Hz
    float rayFrequency = selectedFreq * (SampleRate / 2.0) / NumFrequencyBins;
    
    float angle = ((id.x + random(rng)) / rayCount) * 2 * PI;
    
    float2 rayDir = float2(cos(angle), sin(angle));
    float2 rayPos = sourcePos.xy;
    float curEnergy = inputGain * (freqAmplitudes[selectedFreq] / totalEnergy);
    float accumTime = 0;
    float totalDist = 0;
    float currentIOR = 1.0; 
    float curSpeed = speedOfSound; 
    int wallDepth = 0;

    if (id.x < 100) 
        debugRays[id.x * (maxBounceCount + 1)] = float4(rayPos, curEnergy, 0);

    for (int i = 0; i < maxBounceCount; i++) {
        float closest = inf; int hitIdx = -1;

        for (int w = 0; w < numWalls; w++) {
            float d = intersect(rayPos, rayDir, walls[w].a, walls[w].b);
            if (d < closest) { closest = d; hitIdx = w; }
        }
        
        if (wallDepth == 0) {
            float distToListener = intersectCircle(rayPos, rayDir, listenerPos.xy, listenerRadius);
            if (distToListener < closest && distToListener < inf) {
                RayInfo info;
                info.hitPoint = rayPos + rayDir * distToListener; 
                info.timeDelay = accumTime + (distToListener / curSpeed);
                info.frequency = rayFrequency;
                float totalD = totalDist + distToListener;
                info.energy = curEnergy / max(1.0, totalD * totalD);
                rayInfoBuffer.Append(info);
            }
        }
        
        if (hitIdx == -1) {
            if (id.x < (uint)debugRayCount) 
                debugRays[id.x * (maxBounceCount + 1) + (i + 1)] = float4(rayPos + rayDir * 20.0, 0, 0);
            break;
        }

        rayPos += rayDir * closest;
        accumTime += closest / curSpeed;
        totalDist += closest;

        if (id.x < 100) 
            debugRays[id.x * (maxBounceCount + 1) + (i + 1)] = float4(rayPos, curEnergy, 0);
        
        Wall wall = walls[hitIdx];

        if (wallDepth == 0) {
            float2 toList = listenerPos.xy - rayPos;
            float distList = length(toList);

            if (checkVis(rayPos + wall.normal * eps, listenerPos.xy, distList)) {
                float2 effN = dot(rayDir, wall.normal) > 0 ? -wall.normal : wall.normal;
                float cosT = max(0, dot(effN, toList / distList));
                float totalD = totalDist + distList;
                float contrib = curEnergy * (1.0 - wall.mat.absorption) * (cosT * 0.5) * (1.0 / (totalD*totalD));

                if (contrib > 1e-5) {
                    RayInfo info;
                    info.hitPoint = rayPos;
                    info.timeDelay = accumTime + (distList / speedOfSound);
                    info.frequency = rayFrequency;
                    info.energy = contrib;
                    rayInfoBuffer.Append(info);
                }
            }
        }
        
        curEnergy *= (1.0 - wall.mat.absorption);
        if (curEnergy < 1e-3) break;

        bool entering = dot(rayDir, wall.normal) < 0;
        float2 n = entering ? wall.normal : -wall.normal;
        float wallSpeed = speedOfSound / wall.mat.ior;
        float nextSpeed = entering ? wallSpeed : ((wallDepth <= 1) ? speedOfSound : wallSpeed);
        float eta = nextSpeed / curSpeed;
        float rngVal = random(rng);

        if (rngVal < wall.mat.transmission) {
            float3 refr = Refract(float3(rayDir, 0), float3(n, 0), eta);
            
            if (length(refr) > 0) {
                float2 nextDir = refr.xy;
                if (wall.mat.scattering > 0) {
                    float jitter = (random(rng) - 0.5) * 2.0 * wall.mat.scattering;
                    float s = sin(jitter), c = cos(jitter);
                    nextDir = float2(nextDir.x * c - nextDir.y * s, nextDir.x * s + nextDir.y * c);
                }
                rayDir = normalize(nextDir);
                curSpeed = nextSpeed;
                if (entering) wallDepth++; else wallDepth = max(0, wallDepth - 1);
                rayPos += rayDir * eps;
                continue;
            }
        }

        float2 specularDir = reflect(rayDir, n);
        float diffAng = asin(2.0 * random(rng) - 1.0);
        float s = sin(diffAng), c = cos(diffAng);
        float2 diffuseDir = float2(n.x * c - n.y * s, n.x * s + n.y * c);
        rayDir = normalize(lerp(specularDir, diffuseDir, wall.mat.scattering));
        rayPos += n * eps;
    }
}
#pragma kernel ProcessHits
[numthreads(64, 1, 1)]
void ProcessHits(uint3 id : SV_DispatchThreadID) {
    if (id.x >= (uint)HitCount) return;
    RayInfo hit = RawHits[id.x];
    
    // Calculate which time chunk this hit belongs to
    int timeIndex = (int)(hit.timeDelay * SampleRate / ChunkSize);
    int freqIndex = (int)(hit.frequency * NumFrequencyBins / (SampleRate / 2.0));
    
    if (timeIndex >= 0 && timeIndex < TimeSteps && freqIndex >= 0 && freqIndex < NumFrequencyBins) {
        int spectrogramIndex = timeIndex * NumFrequencyBins + freqIndex;
        Spectrogram[spectrogramIndex] = Spectrogram[spectrogramIndex] + hit.energy;
    }
}

int SpectrogramSize;
#pragma kernel ClearSpectrogram
[numthreads(256, 1, 1)]
void ClearSpectrogram(uint3 id : SV_DispatchThreadID) {
    if (id.x < (uint)SpectrogramSize)
        Spectrogram[id.x] = 0.0;
}



#pragma kernel DrawSpectrogram
#pragma kernel DrawWaveform

RWTexture2D<float4> DebugTexture; 
StructuredBuffer<float> WaveformData;
int WaveformLength;

[numthreads(8, 8, 1)]
void DrawSpectrogram(uint3 id : SV_DispatchThreadID) {
    if (id.x >= (uint)TexWidth || id.y >= (uint)TexHeight) return;
    
    float uvX = id.x / (float)TexWidth;
    float uvY = id.y / (float)TexHeight;

    // X axis = time, Y axis = frequency
    int timeIndex = (int)(uvX * TimeSteps);
    int freqIndex = (int)(uvY * NumFrequencyBins);

    float amp = 0;
    if (timeIndex < TimeSteps && freqIndex < NumFrequencyBins) {
        int spectrogramIndex = timeIndex * NumFrequencyBins + freqIndex;
        amp = Spectrogram[spectrogramIndex] / max(1, accumCount);
    }
    
    // Color based on amplitude (heat map style)
    float intensity = saturate(amp * DebugGain);
    float4 col = float4(intensity, intensity * 0.5, 0, 1);
    DebugTexture[id.xy] = col;
}

[numthreads(8, 8, 1)]
void DrawWaveform(uint3 id : SV_DispatchThreadID) {
    if (id.x >= (uint)TexWidth || id.y >= (uint)TexHeight) return;
    
    // Clear to dark background
    float4 col = float4(0.05, 0.05, 0.1, 1);
    
    // Map x to waveform sample index
    if (WaveformLength > 0) {
        float u = id.x / (float)max(1, TexWidth - 1);
        int sampleIndex = (int)(u * (WaveformLength - 1));
        sampleIndex = clamp(sampleIndex, 0, WaveformLength - 1);
        
        float amp = WaveformData[sampleIndex];
        float ampScaled = saturate(abs(amp) * DebugGain * 50.0);
        
        // Centered waveform
        float midY = (TexHeight - 1) * 0.5;
        float waveY = midY + amp * midY;
        float dist = abs((float)id.y - waveY);
        float thickness = 1.5; // pixels
        
        if (dist <= thickness) {
            col = float4(0.1, 0.8, 1.0, 1);
        } else {
            // Subtle glow based on amplitude
            float glow = saturate(1.0 - dist / (thickness + 6.0)) * ampScaled;
            col += float4(0.1, 0.4, 0.6, 0) * glow;
        }
    }
    
    DebugTexture[id.xy] = col;
}

